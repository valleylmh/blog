(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{441:function(t,l,o){"use strict";o.r(l);var r=o(25),e=Object(r.a)({},(function(){var t=this,l=t.$createElement,o=t._self._c||l;return o("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[o("p",[t._v("排序或许是前端接触最多的算法了，很多人的算法之路是从一个冒泡排序开始的，排序的方法有非常多中，它们各自有各自的应用场景和优缺点，这里我推荐如下6种应用最多的排序方法，如果你有兴趣也可以研究下其他几种。")]),t._v(" "),o("ul",[o("li",[o("RouterLink",{attrs:{to:"/algorithm/排序/快速排序.html"}},[t._v("快速排序")])],1)]),t._v(" "),o("blockquote",[o("p",[t._v("选择一个目标值，比目标值小的放左边，比目标值大的放右边，目标值的位置已排好，将左右两侧再进行快排。")])]),t._v(" "),o("ul",[o("li",[o("RouterLink",{attrs:{to:"/algorithm/排序/归并排序.html"}},[t._v("归并排序")])],1)]),t._v(" "),o("blockquote",[o("p",[t._v("将大序列二分成小序列，将小序列排序后再将排序后的小序列归并成大序列。")])]),t._v(" "),o("ul",[o("li",[o("RouterLink",{attrs:{to:"/algorithm/排序/选择排序.html"}},[t._v("选择排序")])],1)]),t._v(" "),o("blockquote",[o("p",[t._v("每次排序取一个最大或最小的数字放到前面的有序序列中。")])]),t._v(" "),o("ul",[o("li",[o("RouterLink",{attrs:{to:"/algorithm/排序/插入排序.html"}},[t._v("插入排序")])],1)]),t._v(" "),o("blockquote",[o("p",[t._v("将左侧序列看成一个有序序列，每次将一个数字插入该有序序列。插入时，从有序序列最右侧开始比较，若比较的数较大，后移一位。")])]),t._v(" "),o("ul",[o("li",[o("RouterLink",{attrs:{to:"/algorithm/排序/冒泡排序.html"}},[t._v("冒泡排序")])],1)]),t._v(" "),o("blockquote",[o("p",[t._v("循环数组，比较当前元素和下一个元素，如果当前元素比下一个元素大，向上冒泡。下一次循环继续上面的操作，不循环已经排序好的数。")])]),t._v(" "),o("ul",[o("li",[o("RouterLink",{attrs:{to:"/algorithm/排序/堆排序.html"}},[t._v("堆排序")])],1)]),t._v(" "),o("blockquote",[o("p",[t._v("创建一个大顶堆，大顶堆的堆顶一定是最大的元素。交换第一个元素和最后一个元素，让剩余的元素继续调整为大顶堆。从后往前以此和第一个元素交换并重新构建，排序完成。")])])])}),[],!1,null,null,null);l.default=e.exports}}]);