:::tip 名言警句
学会输出就是事半功倍学习
:::


# Node.js是什么？
Node.js是一个能够在服务器端运行JavaScript的开放源代码、跨平台JavaScript运行环境。Node.js由Node.js基金会持有和维护，并与Linux基金会有合作关系。Node.js采用Google开发的V8运行代码，使用**事件驱动、非阻塞异步I/O**等技术来提高性能，可优化应用程序的传输量和规模。这些技术通常用于数据密集的即时应用程序。
>*Node不是一门语言，也不是一个框架，是基于Chrome V8引擎的JavaScript运行时环境；同时结合libuv扩展了JavaScript的功能，使得JavaScript能够支持浏览器DOM的操作，同时具有了后端语言才有的I/O，文件读写和操作数据库的能力，是目前最简单的全栈环境。*

## Node.js特点
### 1. 适合构建WEB应用
构建网站、构建API网关、构建RPC通信BFF层、前后端分离以及适用于火热的Serverless。

###2. 高性能
- `执行速度开` 构建在优秀的V8引擎上，执行速度在动态语言中算最快的
- `天生异步` *事件驱动和非阻塞I/O* 特性决定了必须要采用异步的方式，实际上每个I/O都是异步的，因此集成到libuv中才会让开发者感觉不到并发的存在。
###3. 简单和可扩展
- 语法简单，并发编程简单，部署运维简单，开发简单，可以使用大量的`npm`模块，也可以通过编写`C++`实现`CPU`密集型任务

# Node.js事件循环
详细的介绍`Event Loop`之前我们先来说明一下通常的一个概念混淆：*事件循环和事件驱动*，经常有刚开始的小伙伴会混淆这两个概念，我们上一节已经说过，`libuv`这个库提供两个最重要的东西是事件循环和线程池，两者共同构建了异步非阻塞I/O模型，而事件驱动只是在整个非阻塞I/O模型当中线程池通知事件循环它已经完成I/O操作的这样一种机制而已。

## 六个阶段
![](https://upload-images.jianshu.io/upload_images/3061147-3c5029f1f620d7df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

- `timers 阶段`：这个阶段执行timer（setTimeout、setInterval）的回调
- `I/O callbacks 阶段` ：处理一些上一轮循环中的少数未执行的 I/O 回调
- `idle, prepare 阶段` ：仅node内部使用
- `poll 阶段` ：获取新的I/O事件, 适当的条件下node将阻塞在这里
- `check 阶段` ：执行 setImmediate() 的回调
- `close callbacks 阶段`：执行 socket 的 close 事件回调

>每个阶段都有一个先入先出的（FIFO）的用于执行回调的队列，事件循环运行到每个阶段，都会从对应的回调队列中取出回调函数去执行，直到队列当中的内容耗尽，或者执行的回调数量达到了最大。然后事件循环就会进入下一个阶段，然后又从下一个阶段对应的队列中取出回调函数执行，这样反复直到事件循环的最后一个阶段。而事件循环也会一个一个按照循环执行，直到进程结束。

`注意：上面六个阶段都不包括 process.nextTick() `

## Micro-Task 与 Macro-Task

Node端事件循环中的异步队列也是这两种：`macro`（宏任务）队列和 `micro`（微任务）队列。

*   常见的macro-task：`setTimeout`、`setInterval`、 `setImmediate`、`script（整体代码）`、 `I/O`操作等。
*   常见的micro-task：`process.nextTick`、`new Promise().then`(回调)等。

但是我们要注意有一个很容易混淆的点

*   宏任务队列和微任务队列都只是概念，在node当中没有说哪个具体队列名字就叫做宏任务队列，正确的认知应该是前面我们说的事件循环当中的6个阶段对应的6个基本的队列都属于宏队列
*   比如`timer`阶段对应的是`timer宏队列`，`I/O callback`阶段对应的就是`I/O callback宏队列`,依次类推。

所以事件循环当中的6个宏队列和微队列的关系如下：微队列（microtask）在事件循环的各个阶段之间执行，或者说在事件循环的各个阶段对应的宏队列（macrotask）之间执行 ![node队列](https://upload-images.jianshu.io/upload_images/3061147-49519bff4bde6b65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

但是这里又有一个特别容易混淆的版本改变：

*   `如果是node10及其之前版本：`宏队列当中的有几个宏任务，是要等到宏队列当中的所有宏任务全部执行完毕才会去执行微队列当中的微任务
*   `如果是node11版本：`一旦执行一个阶段里对应宏队列当中的一个宏任务(setTimeout,setInterval和setImmediate三者其中之一，不包括I/O)就立刻执行微任务队列，执行完微队列当中的所有微任务再回到刚才的宏队列执行下一个宏任务。

所以下面我们给出的所有实例我们都会给出不同版本`node`执行的结果。

## process.nextTick

这个函数其实是独立于`Event Loop`之外的，它有一个自己的队列，当每个阶段完成后，如果存在`nextTick`队列，就会清空队列中的所有回调函数，并且优先于其他`microtask`执行。

*   执行机制：`process.nextTick`是用于在事件循环的下一次循环中调用回调函数的，将一个函数推迟到代码执行的下一个同步方法执行完毕，或异步事件回调函数开始执行时再执行
*   执行原理：`Node`每一次循环都是一个`tick`，每次`tick`，`Chrome V8`都会从时间队列当中取所有事件依次处理。遇到`nextTick`事件，将其加入事件队尾，等待下一次`tick`到来的时候执行。

#了不起的Node.js
### 1. 前后端分离

绝大多数开发都是从单体式架构开始的，简单集成度高，上手十分容易，但是在团队协作重度化的今天，多人协作势必会导致专业化分工，前后端分离也伴随而来，典型的企业应用会采用三层架构模式：

*   表现层：处理`HTTP`请求，直接返回`HTML`渲染，或者返回`API`结果，对于复杂的应用系统，表面层通常是代码中比较重要的部分
*   业务逻辑层：完成具体的业务逻辑，是应用的核心组成部分
*   数据访问层：访问基础数据，例如数据库，缓存和消息队列

按照传统的分类方式，表现层就是前端，业务逻辑层和数据访问层都属于后端，而且现在重度API化的今天，后端业务逻辑被削弱了，更多业务逻辑可以被移到前端，比如说：组装API、RPC服务、提供配置、静态API接口等等，除了不直接操作数据库，前端都能承担。当前最常见的模式就是：前端 + API + 后端服务，如下所示：

- *用户客户端 -> 请求 -> Nginx -> node(前端Vue/React) <- (json<-)静态API(->Ajax) -> 后端服务（node、java、Go）*

而上述为什么把前端`Vue/React`也列举为`node`呢，因为本质是使用`node`启动的服务，而单页面应用也是页面即服务的典型应用。

## 2. Web工程化开发
| 编号 | 分类 | 举例 |
| --- | --- | --- |
| 1 | 压缩 | UglifyJS JSmin CSSO |
| 2 | 依赖管理 | npm Bower |
| 3 | 模块系统 | CommonJS AMD ES6module |
| 4 | 模块加载器 | Require.js jspm Sea.js System.js |
| 5 | 模块打包器 | Browerify Webpack |
| 6 | css预处理器 | PostCss Less Sass stylus |
| 7 | 构建工具 | Grunt Gulp |
| 8 | 引擎模板 | Jade Handlebars Numjucks |
| 9 | JavaScript友好语言 | CoffeeScipt Babel Typescript |
| 10 | 跨平台打包工具 | Electron NW.js cordova |
| 11 | 生成器 | yeoman Slush vue-cli create-react-app |

### 3. 后端开发
**① API 代理（API 网关）**
一般后端开发指的是`Web`应用开发当中和视图渲染无关的部分，主要是以数据库交互为主的重业务逻辑处理，但是架构升级之后，`Node`承担了前后端分离的重任，就有了更多的玩法：
*   面向API的接口应用（当前）
*   通过RPC调用封装对数据库进行操作（（当前和未来））
*   提供前端API代理（API Gateway）和网关，服务组装等 （当前和未来）

面向接口的开发应用中如果时间过长或者项目太过复杂的时候就会产生下面的问题：

*   一个页面的`API`非常多
*   跨域
*   `API`返回的数据对前端不太友好
*   需求临时决定需要一个`API`,但是`API`无法及时反馈

所以我们就会想：在包含多种交互的情况下。理想的情况是使用一样的模型，提供基于模型的定制`API`,在`Node`层提供统一的模型，然后包装成前端需要的`API`,这样的`API`是对前端友好的，所以就出现了`单节点API网关（API Gateway）`和`BFF网关（Node中间层）`。

这种API Proxy位于异构API（可能是RESTful API、可能是RPC服务）之前，通过对异构API进行抽象，形成模型层，然后根据各种前端的需求，包装成为对前端友好的API接口

**② 服务组装**

在微服务架构十分流行的今天，服务化可谓是最佳实践，应用非常多的便是基于`TCP`的`RPC`服务，相比较`HTTP`来说效率更高，在结合配置中心，服务注册等，更好的对系统进行解耦，那么复杂的跨服务业务怎么处理，这个时候就需要对服务进行组装。而组装服务的过程也可以在`API Proxy`层进行实现：

![服务组装](https://upload-images.jianshu.io/upload_images/3061147-1bac38a9831ea680.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

所以实际上服务组装的代价都一样，用`Node`为何不好呢？而且放在`Node Proxy`好处十分明显，既可以提高开发效率，又能让后端专注于服务开发，如果前端团队十分强大，可以组件一个`API`小组，从事服务集成的工作。

## 微服务
微服务本身不是什么新技术，只是随着业务的不断发展，对业务不断分层，不断拆分。
>微服务是系统或应用程序中的自包含独立组件。每个微服务都应该有明确的作用域和责任，理想情况下，一个微服务只做一件事。它应该是无状态的或有状态的，如果它是有状态的，它应该带有自己的持久层（即数据库），不与其他服务共享。软件开发团队基于微服务架构以更分散的方式开发可重用的独立组件。他们可以为每个微服务使用自定义框架、依赖关系集，甚至是完全不同的编程语言。微服务也有助于实现可扩展性，因为它们本质上是分布式的，并且每个微服务都可以独立增长或复制。

### 容器与微服务
当我们在谈论定义时，需要注意的是微服务和容器其实是不一样的东西，但这两个概念经常被放在一起谈论，就像API和微服务一样。如果没有容器，要么把服务器配置成可以运行多个微服务，让这些微服务不可避免地相互产生负面干扰，要么每个微服务都需要一个单独的服务器或自己的虚拟机，导致不必要的开销。因此，微服务通常被部署在一组由容器集群软件（如 Kubernetes）管理的一组容器中。可以肯定地说，容器和微服务的崛起其实是相互影响、相互促进的结果。

`网关`说白了就是暴露给外网的一套API接口，或者说门神，然后网关再去调用一个一个微服务，而关于服务器有关的限流，熔断，负载均衡都能在网关这里去做，也是防止一个服务导致整个项目奔溃的解决方案。




